// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDto github com pocket id pocket id backend internal dto app config update dto
//
// swagger:model github_com_pocket-id_pocket-id_backend_internal_dto.AppConfigUpdateDto
type GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDto struct {

	// accent color
	AccentColor string `json:"accentColor,omitempty"`

	// allow own account edit
	// Required: true
	AllowOwnAccountEdit *string `json:"allowOwnAccountEdit"`

	// allow user signups
	// Required: true
	// Enum: ["disabled","withToken","open"]
	AllowUserSignups *string `json:"allowUserSignups"`

	// app name
	// Required: true
	// Max Length: 30
	// Min Length: 1
	AppName *string `json:"appName"`

	// disable animations
	// Required: true
	DisableAnimations *string `json:"disableAnimations"`

	// email Api key expiration enabled
	// Required: true
	EmailAPIKeyExpirationEnabled *string `json:"emailApiKeyExpirationEnabled"`

	// email login notification enabled
	// Required: true
	EmailLoginNotificationEnabled *string `json:"emailLoginNotificationEnabled"`

	// email one time access as admin enabled
	// Required: true
	EmailOneTimeAccessAsAdminEnabled *string `json:"emailOneTimeAccessAsAdminEnabled"`

	// email one time access as unauthenticated enabled
	// Required: true
	EmailOneTimeAccessAsUnauthenticatedEnabled *string `json:"emailOneTimeAccessAsUnauthenticatedEnabled"`

	// emails verified
	// Required: true
	EmailsVerified *string `json:"emailsVerified"`

	// ldap admin group name
	LdapAdminGroupName string `json:"ldapAdminGroupName,omitempty"`

	// ldap attribute group member
	LdapAttributeGroupMember string `json:"ldapAttributeGroupMember,omitempty"`

	// ldap attribute group name
	LdapAttributeGroupName string `json:"ldapAttributeGroupName,omitempty"`

	// ldap attribute group unique identifier
	LdapAttributeGroupUniqueIdentifier string `json:"ldapAttributeGroupUniqueIdentifier,omitempty"`

	// ldap attribute user display name
	LdapAttributeUserDisplayName string `json:"ldapAttributeUserDisplayName,omitempty"`

	// ldap attribute user email
	LdapAttributeUserEmail string `json:"ldapAttributeUserEmail,omitempty"`

	// ldap attribute user first name
	LdapAttributeUserFirstName string `json:"ldapAttributeUserFirstName,omitempty"`

	// ldap attribute user last name
	LdapAttributeUserLastName string `json:"ldapAttributeUserLastName,omitempty"`

	// ldap attribute user profile picture
	LdapAttributeUserProfilePicture string `json:"ldapAttributeUserProfilePicture,omitempty"`

	// ldap attribute user unique identifier
	LdapAttributeUserUniqueIdentifier string `json:"ldapAttributeUserUniqueIdentifier,omitempty"`

	// ldap attribute user username
	LdapAttributeUserUsername string `json:"ldapAttributeUserUsername,omitempty"`

	// ldap base
	LdapBase string `json:"ldapBase,omitempty"`

	// ldap bind dn
	LdapBindDn string `json:"ldapBindDn,omitempty"`

	// ldap bind password
	LdapBindPassword string `json:"ldapBindPassword,omitempty"`

	// ldap enabled
	// Required: true
	LdapEnabled *string `json:"ldapEnabled"`

	// ldap skip cert verify
	LdapSkipCertVerify string `json:"ldapSkipCertVerify,omitempty"`

	// ldap soft delete users
	LdapSoftDeleteUsers string `json:"ldapSoftDeleteUsers,omitempty"`

	// ldap Url
	LdapURL string `json:"ldapUrl,omitempty"`

	// ldap user group search filter
	LdapUserGroupSearchFilter string `json:"ldapUserGroupSearchFilter,omitempty"`

	// ldap user search filter
	LdapUserSearchFilter string `json:"ldapUserSearchFilter,omitempty"`

	// require user email
	// Required: true
	RequireUserEmail *string `json:"requireUserEmail"`

	// session duration
	// Required: true
	SessionDuration *string `json:"sessionDuration"`

	// signup default custom claims
	SignupDefaultCustomClaims string `json:"signupDefaultCustomClaims,omitempty"`

	// signup default user group i ds
	SignupDefaultUserGroupIDs string `json:"signupDefaultUserGroupIDs,omitempty"`

	// smtp from
	SMTPFrom string `json:"smtpFrom,omitempty"`

	// smtp host
	SMTPHost string `json:"smtpHost,omitempty"`

	// smtp password
	SMTPPassword string `json:"smtpPassword,omitempty"`

	// smtp port
	SMTPPort string `json:"smtpPort,omitempty"`

	// smtp skip cert verify
	SMTPSkipCertVerify string `json:"smtpSkipCertVerify,omitempty"`

	// smtp Tls
	// Required: true
	// Enum: ["none","starttls","tls"]
	SMTPTLS *string `json:"smtpTls"`

	// smtp user
	SMTPUser string `json:"smtpUser,omitempty"`
}

// Validate validates this github com pocket id pocket id backend internal dto app config update dto
func (m *GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDto) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAllowOwnAccountEdit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAllowUserSignups(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAppName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDisableAnimations(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmailAPIKeyExpirationEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmailLoginNotificationEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmailOneTimeAccessAsAdminEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmailOneTimeAccessAsUnauthenticatedEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateEmailsVerified(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateLdapEnabled(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateRequireUserEmail(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSessionDuration(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateSMTPTLS(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDto) validateAllowOwnAccountEdit(formats strfmt.Registry) error {

	if err := validate.Required("allowOwnAccountEdit", "body", m.AllowOwnAccountEdit); err != nil {
		return err
	}

	return nil
}

var githubComPocketIdPocketIdBackendInternalDtoAppConfigUpdateDtoTypeAllowUserSignupsPropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["disabled","withToken","open"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		githubComPocketIdPocketIdBackendInternalDtoAppConfigUpdateDtoTypeAllowUserSignupsPropEnum = append(githubComPocketIdPocketIdBackendInternalDtoAppConfigUpdateDtoTypeAllowUserSignupsPropEnum, v)
	}
}

const (

	// GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDtoAllowUserSignupsDisabled captures enum value "disabled"
	GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDtoAllowUserSignupsDisabled string = "disabled"

	// GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDtoAllowUserSignupsWithToken captures enum value "withToken"
	GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDtoAllowUserSignupsWithToken string = "withToken"

	// GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDtoAllowUserSignupsOpen captures enum value "open"
	GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDtoAllowUserSignupsOpen string = "open"
)

// prop value enum
func (m *GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDto) validateAllowUserSignupsEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, githubComPocketIdPocketIdBackendInternalDtoAppConfigUpdateDtoTypeAllowUserSignupsPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDto) validateAllowUserSignups(formats strfmt.Registry) error {

	if err := validate.Required("allowUserSignups", "body", m.AllowUserSignups); err != nil {
		return err
	}

	// value enum
	if err := m.validateAllowUserSignupsEnum("allowUserSignups", "body", *m.AllowUserSignups); err != nil {
		return err
	}

	return nil
}

func (m *GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDto) validateAppName(formats strfmt.Registry) error {

	if err := validate.Required("appName", "body", m.AppName); err != nil {
		return err
	}

	if err := validate.MinLength("appName", "body", *m.AppName, 1); err != nil {
		return err
	}

	if err := validate.MaxLength("appName", "body", *m.AppName, 30); err != nil {
		return err
	}

	return nil
}

func (m *GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDto) validateDisableAnimations(formats strfmt.Registry) error {

	if err := validate.Required("disableAnimations", "body", m.DisableAnimations); err != nil {
		return err
	}

	return nil
}

func (m *GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDto) validateEmailAPIKeyExpirationEnabled(formats strfmt.Registry) error {

	if err := validate.Required("emailApiKeyExpirationEnabled", "body", m.EmailAPIKeyExpirationEnabled); err != nil {
		return err
	}

	return nil
}

func (m *GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDto) validateEmailLoginNotificationEnabled(formats strfmt.Registry) error {

	if err := validate.Required("emailLoginNotificationEnabled", "body", m.EmailLoginNotificationEnabled); err != nil {
		return err
	}

	return nil
}

func (m *GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDto) validateEmailOneTimeAccessAsAdminEnabled(formats strfmt.Registry) error {

	if err := validate.Required("emailOneTimeAccessAsAdminEnabled", "body", m.EmailOneTimeAccessAsAdminEnabled); err != nil {
		return err
	}

	return nil
}

func (m *GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDto) validateEmailOneTimeAccessAsUnauthenticatedEnabled(formats strfmt.Registry) error {

	if err := validate.Required("emailOneTimeAccessAsUnauthenticatedEnabled", "body", m.EmailOneTimeAccessAsUnauthenticatedEnabled); err != nil {
		return err
	}

	return nil
}

func (m *GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDto) validateEmailsVerified(formats strfmt.Registry) error {

	if err := validate.Required("emailsVerified", "body", m.EmailsVerified); err != nil {
		return err
	}

	return nil
}

func (m *GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDto) validateLdapEnabled(formats strfmt.Registry) error {

	if err := validate.Required("ldapEnabled", "body", m.LdapEnabled); err != nil {
		return err
	}

	return nil
}

func (m *GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDto) validateRequireUserEmail(formats strfmt.Registry) error {

	if err := validate.Required("requireUserEmail", "body", m.RequireUserEmail); err != nil {
		return err
	}

	return nil
}

func (m *GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDto) validateSessionDuration(formats strfmt.Registry) error {

	if err := validate.Required("sessionDuration", "body", m.SessionDuration); err != nil {
		return err
	}

	return nil
}

var githubComPocketIdPocketIdBackendInternalDtoAppConfigUpdateDtoTypeSMTPTLSPropEnum []any

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["none","starttls","tls"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		githubComPocketIdPocketIdBackendInternalDtoAppConfigUpdateDtoTypeSMTPTLSPropEnum = append(githubComPocketIdPocketIdBackendInternalDtoAppConfigUpdateDtoTypeSMTPTLSPropEnum, v)
	}
}

const (

	// GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDtoSMTPTLSNone captures enum value "none"
	GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDtoSMTPTLSNone string = "none"

	// GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDtoSMTPTLSStarttls captures enum value "starttls"
	GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDtoSMTPTLSStarttls string = "starttls"

	// GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDtoSMTPTLSTLS captures enum value "tls"
	GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDtoSMTPTLSTLS string = "tls"
)

// prop value enum
func (m *GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDto) validateSMTPTLSEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, githubComPocketIdPocketIdBackendInternalDtoAppConfigUpdateDtoTypeSMTPTLSPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDto) validateSMTPTLS(formats strfmt.Registry) error {

	if err := validate.Required("smtpTls", "body", m.SMTPTLS); err != nil {
		return err
	}

	// value enum
	if err := m.validateSMTPTLSEnum("smtpTls", "body", *m.SMTPTLS); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this github com pocket id pocket id backend internal dto app config update dto based on context it is used
func (m *GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDto) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDto) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDto) UnmarshalBinary(b []byte) error {
	var res GithubComPocketIDPocketIDBackendInternalDtoAppConfigUpdateDto
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
